using "edom" : 0;

namespace "esvg" : 0 {
	/* basic types */
	struct "esvg_length" {
		double "value";
		int "unit";
	};

	struct "esvg_viewbox" {
		double "min_x";
		double "min_y";
		double "width";
		double "height";
	};

	/* the color needs a byte definition or int8 in ender */
	struct "esvg_color" {
		int "r";
		int "g";
		int "b";
	};

	struct "esvg_point" {
		double "x";
		double "y";
	};

	union "esvg_paint" {
		/* fix this */
		bool "none";
		bool "current_color";
		esvg_color "color";
		string "paint_server";
	};

	/* animated types */
	struct "esvg_animated_number" {
		double "base";
		double "anim";
	};

	struct "esvg_animated_transform" {
		matrix "base";
		matrix "anim";
	};

	struct "esvg_animated_string" {
		string "base";
		string "anim";
	};

	struct "esvg_animated_bool" {
		bool "base";
		bool "anim";
	};

	struct "esvg_animated_length" {
		esvg_length "base";
		esvg_length "anim";
	};

	struct "esvg_animated_color" {
		esvg_color "base";
		esvg_color "anim";
	};

	struct "esvg_animated_paint" {
		esvg_paint "base";
		esvg_paint "anim";
	};

	union "esvg_duration" {
		/* fix we should include the long variants on ender */
		long "clock";
	};

	struct "esvg_path_vline_to" {
		double "c";
	};

	union "esvg_path_command" {
		esvg_path_simple_line "hline";
		esvg_path_simple_line "vline";
	};

	struct "esvg_animated_path_command" {
		[esvg_path_command] "base";
		[esvg_path_command] "anim";
	};

	/* objects */

	abstract "element" : "tag" {
		/* core */
		int "type";
		/* dom */
		string "id";
		string "class";
		string "style";
		/* presentation attributes */
		esvg_animated_string "clip-path";
		esvg_animated_number "opacity";
		/* once the color is done we can the union paint for filling and stroking */
		esvg_animated_color "color";
		esvg_animated_paint "fill";
		esvg_animated_paint "stroke";
		esvg_animated_length "stroke-width";
		esvg_animated_number "fill-opacity";
		esvg_animated_number "stroke-opacity";
		esvg_animated_bool "visibility";
		esvg_animated_color "stop-color";
		esvg_animated_number "stop-opacity";
		/* other attributes */
		esvg_animated_transform "transform";
		ender "topmost";
	};

	abstract "referenceable" : "element" {

	};

	abstract "renderable" : "element" {
		object "renderer";
		double "container_width";
		double "container_height";
		double "x_dpi";
		double "y_dpi";
	};

	abstract "paint_server" : "referenceable" {

	};

	class "clip_path" : "referenceable" {
		int "clip_path_units";
	};

	abstract "gradient" : "paint_server" {
		string "href";
		int "spread_method";
		int "gradient_units";
		esvg_animated_transform "gradient_transform";
	};

	abstract "animation" : "element" {
		string "attribute_name";
		int "attribute_type";
		int "additive";
		int "accumulate";
		int "repeat_count";
		/* FIXME later we should use a time object? */
		esvg_duration "dur";
	};

	abstract "animate_base" : "animation" {
		string "from";
		string "to";
		string "values";
		int "calc_mode";
		string "key_times";
		string "key_splines";
	};

	class "animate" : "animate_base" {

	};

	class "animate_transform" : "animate_base" {
		int "type";
	};

	class "style" : "element" {

	};

	class "linear_gradient" : "gradient" {
		esvg_length "x1";
		esvg_length "y1";
		esvg_length "x2";
		esvg_length "y2";
	};

	class "radial_gradient" : "gradient" {
		esvg_length "cx";
		esvg_length "cy";
		esvg_length "fx";
		esvg_length "fy";
		esvg_length "r";
	};

	class "svg" : "renderable" {
		esvg_length "x";
		esvg_length "y";
		esvg_length "width";
		esvg_length "height";
		double "actual_width";
		double "actual_height";
		esvg_viewbox "viewbox";
	};

	class "g" : "renderable" {

	};

	class "use" : "renderable" {
		esvg_length "x";
		esvg_length "y";
		esvg_length "width";
		esvg_length "height";
		string "link";
	};

	class "rect" : "renderable" {
		esvg_animated_length "x";
		esvg_animated_length "y";
		esvg_animated_length "width";
		esvg_animated_length "height";
		esvg_animated_length "rx";
		esvg_animated_length "ry";
	};

	class "ellipse" : "renderable" {
		esvg_length "cx";
		esvg_length "cy";
		esvg_length "rx";
		esvg_length "ry";
	};

	class "circle" : "renderable" {
		esvg_length "cx";
		esvg_length "cy";
		esvg_length "r";
	};

	class "path" : "renderable" {
		esvg_animated_path_command "d";
	};

	class "line" : "renderable" {
		esvg_length "x1";
		esvg_length "x2";
		esvg_length "y1";
		esvg_length "y2";
	};

	class "polyline" : "renderable" {
		[esvg_point] "point";
	};

	class "polygon" : "renderable" {
		[esvg_point] "point";
	};

	class "text" : "renderable" {
		esvg_length "x";
		esvg_length "y";
	};

	class "stop" : "element" {
		esvg_length "offset";
	};

	class "defs" : "element" {

	};

	class "a" : "element" {
		string "href";
	};

	class "image" : "renderable" {
		esvg_animated_length "x";
		esvg_animated_length "y";
		esvg_animated_length "width";
		esvg_animated_length "height";
		esvg_animated_string "xlink:href";
	};

};

